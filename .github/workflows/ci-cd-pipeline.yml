name: EKS Microservices CI/CD

on:
  push:
    branches: [ main ]
    paths:
      - 'vote/**'       # Trigger when vote service changes
      - 'result/**'     # Trigger when result service changes
      - 'worker/**'     # Trigger when worker service changes
      - 'k8s/**'        # Trigger when k8s manifests change
  workflow_dispatch:  # Allow manual triggers

env:
  AWS_REGION: us-east-2
  EKS_CLUSTER_NAME: ironhack-main  # cluster name where i work
  DOCKERHUB_USERNAME: chinmayee606
  NAMESPACE: chinmayee

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [vote, result, worker]      # Run in parallel for all 3 services
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Build and push Docker image
      run: |
        SHORT_SHA=${GITHUB_SHA:0:8}
        IMAGE_TAG="${{ env.DOCKERHUB_USERNAME }}/${{ matrix.service }}:$SHORT_SHA"
        
        # Build the image
        docker build -t $IMAGE_TAG ./${{ matrix.service }}
        
        # Push to Docker Hub
        docker push $IMAGE_TAG
        
        # Also tag as latest for the current branch
        docker tag $IMAGE_TAG ${{ env.DOCKERHUB_USERNAME }}/${{ matrix.service }}:latest
        docker push ${{ env.DOCKERHUB_USERNAME }}/${{ matrix.service }}:latest
        
        echo "image_tag=$IMAGE_TAG" >> $GITHUB_ENV

    - name: Update Kubernetes manifests
      run: |
        SHORT_SHA=${GITHUB_SHA:0:8}
        IMAGE_TAG="${{ env.DOCKERHUB_USERNAME }}/${{ matrix.service }}:$SHORT_SHA"
        
        if [ "${{ matrix.service }}" == "vote" ]; then
          sed -i "s|image: chinmayee606/vote:latest|image: $IMAGE_TAG|" k8s/vote-deployment.yaml
        elif [ "${{ matrix.service }}" == "result" ]; then
          sed -i "s|image: chinmayee606/result:latest|image: $IMAGE_TAG|" k8s/result-deployment.yaml
        elif [ "${{ matrix.service }}" == "worker" ]; then
          sed -i "s|image: chinmayee606/worker:latest|image: $IMAGE_TAG|" k8s/worker-deployment.yaml
        fi

    - name: Upload updated manifests
      uses: actions/upload-artifact@v4
      with:
        name: k8s-manifests-${{ matrix.service }}
        path: k8s/
        retention-days: 1

  deploy-to-eks:
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download all manifests
      uses: actions/download-artifact@v4
      with:
        name: k8s-manifests-vote
        path: k8s-combined/
      
    - name: Download result manifests  
      uses: actions/download-artifact@v4
      with:
        name: k8s-manifests-result
        path: k8s-combined/

    - name: Download worker manifests
      uses: actions/download-artifact@v4
      with:
        name: k8s-manifests-worker
        path: k8s-combined/

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig \
          --region ${{ env.AWS_REGION }} \
          --name ${{ env.EKS_CLUSTER_NAME }}

    - name: Create namespace if not exists
      run: |
        kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

    - name: Deploy databases first
      run: |
        echo "Deploying PostgreSQL..."
        kubectl apply -f k8s/postgres-deployment.yaml -n ${{ env.NAMESPACE }}
        kubectl apply -f k8s/postgres-service.yaml -n ${{ env.NAMESPACE }}
        
        echo "Deploying Redis..."
        kubectl apply -f k8s/redis-deployment.yaml -n ${{ env.NAMESPACE }}
        kubectl apply -f k8s/redis-service.yaml -n ${{ env.NAMESPACE }}
        
        # Wait for databases to be ready
        echo "Waiting for databases to be ready..."
        kubectl wait --for=condition=ready pod -l app=chinmayee-postgres -n ${{ env.NAMESPACE }} --timeout=180s
        kubectl wait --for=condition=ready pod -l app=chinmayee-redis -n ${{ env.NAMESPACE }} --timeout=180s

    - name: Deploy microservices
      run: |
        echo "Deploying vote service..."
        kubectl apply -f k8s/vote-deployment.yaml -n ${{ env.NAMESPACE }}
        kubectl apply -f k8s/vote-service.yaml -n ${{ env.NAMESPACE }}
        
        echo "Deploying result service..."
        kubectl apply -f k8s/result-deployment.yaml -n ${{ env.NAMESPACE }}
        kubectl apply -f k8s/result-service.yaml -n ${{ env.NAMESPACE }}
        
        echo "Deploying worker service..."
        kubectl apply -f k8s/worker-deployment.yaml -n ${{ env.NAMESPACE }}

    - name: Deploy ingress
      run: |
        echo "Deploying ingress..."
        kubectl apply -f k8s/ingress.yaml -n ${{ env.NAMESPACE }}

    - name: Wait for deployments to complete
      run: |
        echo "Waiting for deployments to be ready..."
        kubectl rollout status deployment/chinmayee-deployment-vote -n ${{ env.NAMESPACE }} --timeout=300s
        kubectl rollout status deployment/chinmayee-deployment-result -n ${{ env.NAMESPACE }} --timeout=300s
        kubectl rollout status deployment/chinmayee-deployment-worker -n ${{ env.NAMESPACE }} --timeout=300s

    - name: Verify deployment
      run: |
        echo "=== Deployment Status ==="
        kubectl get deployments -n ${{ env.NAMESPACE }}
        echo ""
        echo "=== Pods Status ==="
        kubectl get pods -n ${{ env.NAMESPACE }}
        echo ""
        echo "=== Services Status ==="
        kubectl get services -n ${{ env.NAMESPACE }}
        echo ""
        echo "=== Ingress Status ==="
        kubectl get ingress -n ${{ env.NAMESPACE }}

    - name: Simple health check
      run: |
        # Wait a bit for everything to settle
        sleep 30
        
        # Check if pods are running
        RUNNING_PODS=$(kubectl get pods -n ${{ env.NAMESPACE }} --field-selector=status.phase=Running --no-headers | wc -l)
        echo "Running pods: $RUNNING_PODS"
        
        if [ $RUNNING_PODS -ge 5 ]; then
          echo "Deployment successful - all expected pods are running"
        else
          echo "Some pods might not be running yet"
          kubectl get pods -n ${{ env.NAMESPACE }}
        fi
        